import KernelAbstractions
import KernelAbstractions: Backend

struct ROCArrayBackend <: Backend end

function GPUArrays.derive(
    ::Type{T}, x::ROCArray, dims::Dims{N}, offset::Int,
) where {N, T}
    ref = copy(x.buf)
    offset += (x.offset * Base.elsize(x)) รท sizeof(T)
    ROCArray{T, N}(ref, dims; offset)
end

# @roc conversion

function Base.convert(
    ::Type{ROCDeviceArray{T, N, AS.Global}}, a::ROCArray{T, N},
) where {T, N}
    # If HostBuffer, use device pointer.
    ptr = Base.unsafe_convert(Ptr{T},
        typeof(a.buf[]) <: Mem.HIPBuffer ? a.buf[] : a.buf[].dev_ptr)
    llvm_ptr = AMDGPU.LLVMPtr{T,AS.Global}(ptr + a.offset * sizeof(T))
    ROCDeviceArray{T, N, AS.Global}(a.dims, llvm_ptr)
end

Adapt.adapt_storage(::Runtime.Adaptor, x::ROCArray{T,N}) where {T,N} =
    convert(ROCDeviceArray{T,N,AS.Global}, x)
